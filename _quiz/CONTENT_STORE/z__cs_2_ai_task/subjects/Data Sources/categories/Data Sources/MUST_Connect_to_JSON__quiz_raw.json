{    "question_1": {        "question": "What is the primary difference between the REST provider and the CData data source for connecting to JSON data?",        "options": {            "option_a": "CData data source can only connect to JSON data in APIs, not files.",            "option_b": "CData data source is used exclusively for JSON data.",            "option_c": "REST provider cannot handle pagination parameters.",            "option_d": "CData data source does not support incremental load."        },        "answer": "option_b",        "explanation": "The CData data source is used exclusively for JSON data, whereas the REST provider can be used for various types of data. Both can handle similar functionalities, but CData is specific to JSON."    },    "question_2": {        "question": "When setting up a CData connector to a JSON data source, what is the first step according to the guide?",        "options": {            "option_a": "Paste in the link to the JSON resource location.",            "option_b": "Set up incremental load and data type overwrites.",            "option_c": "Check the online documentation for the JSON guide from CData.",            "option_d": "Configure the JSON Path in the data source field."        },        "answer": "option_c",        "explanation": "The first step in setting up a CData connector is to check the online documentation for the JSON guide from CData, ensuring proper configuration and usage."    },    "question_3": {        "question": "What does the 'Relational' option do when parsing hierarchical data in JSON?",        "options": {            "option_a": "It flattens the nested objects into one large table.",            "option_b": "It creates a table for each nested object with relational IDs.",            "option_c": "It ignores nested objects and only parses top-level data.",            "option_d": "It sets the JSON Path to the deepest nested object."        },        "answer": "option_b",        "explanation": "The 'Relational' option creates a separate table for each nested part of the JSON data and establishes relational IDs to link these tables."    },    "question_4": {        "question": "What is the JSONPath syntax used to identify the column and row paths in the JSONRows format?",        "options": {            "option_a": "column:$.dataset.column_names;row:$.dataset.data",            "option_b": "column:$.columns;row:$.rows",            "option_c": "column:$.columns.name;row:$.rows",            "option_d": "column:$.dataset.data;row:$.dataset.column_names"        },        "answer": "option_a",        "explanation": "The JSONPath syntax for identifying column and row paths in the JSONRows format is specified using a 'column:' and 'row:' prefix, as in 'column:$.dataset.column_names;row:$.dataset.data'."    },    "question_5": {        "question": "Which JSON format should be used in the majority of cases according to the guide?",        "options": {            "option_a": "LDJSON",            "option_b": "JSONRows",            "option_c": "JSON",            "option_d": "RSD File Customization"        },        "answer": "option_c",        "explanation": "The default JSON format is recommended for use in the majority of cases when connecting to JSON data sources."    },    "question_6": {        "question": "What is the purpose of the 'Flatten Documents' option when working with JSON data?",        "options": {            "option_a": "To create a relational database schema from JSON data.",            "option_b": "To parse line-delimited JSON files.",            "option_c": "To combine nested JSON objects into one large table.",            "option_d": "To generate a RSD file for complex JSON structures."        },        "answer": "option_c",        "explanation": "The 'Flatten Documents' option is used to combine all nested JSON objects into one large table, simplifying the data structure."    }}