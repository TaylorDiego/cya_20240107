{
    "DateTime": "2023-12-27 14:42:28",
    "URL": "https://support.timextender.com/data-sources-112/advanced-rsd-file-options-884",
    "Keywords": "missing",
    "Title": "Advanced RSD file options _ Community",
    "Author": "Thomas Lind",
    "Text": "Here is the advanced options that you can use an RSD file to achieve. Generate and use RSD files Pagination is a method where you iterate through a number of pages until you hit the end and get all the data out of the API for a specific resource. There are two ways of doing this and it depends on what your API supports. One requirement is to add the following <info> Using nested calls to get info from multiple pages If the service provides a record offset query parameter to control paging, you can implement this by setting the name of the offset query parameter, the name of the page size query parameter, and the page size to be passed. Note that the page size parameter does not need to be set if there is no parameter to control this. In this case, you must set pagesize to the default page size. The offset and size parameter options may have different names, but these should be mentioned in the API documentation. Similar to record offset, if the service provides a query parameter that sets the page number, you can implement this by setting the name of the page number query parameter, the name of the page size query parameter, and the page size to be passed. Note that the page size parameter does not need to be set if there is no parameter to control this. In this case, you must set pagesize to the default page size. This is a new method, so it can possibly work for most of the options regarding page that have a page and pagesize or pagecount option in the API. So this may be used instead of the IF and Enum options explained below. RFC-8288 In more detail, the following information is included in the Header: The following method is for the PushResponseHeader Page method. The previous also can be used to get the last page, then you can make a if statement where you will set the next page until you reach the last. It could look something like this. Remember that the GoREST provider doesn't use this, so you can't make this exact thing work. OKTA It actually is possible to use this to do pagination as well. It is a very simple setup as well. rows@next pageurlpath Header:Link Remember that the GoREST provider doesn't use this, so you can't make this exact thing work. If the next page URL is passed in the response body, set 'pageurlpath' to the XPath of the element. swapi.dev So here is how you would make pagination work for the people page. I just added a repeat element and set enablepaging = true and added a pageurlpath that corresponds to the next page. I have added it and another method to achieve the same thing as people.rsd and People_RWNE.rsd To make the GoREST work with pagination you can set up an if statement that takes the last page and the current page and uses them to iterate through. If we takes a look at one of them, like users for example. You can see that it has some pagination info on the top of the json data. What we want are the pages value and the page value to be added as variables in our code. To do so we can use the element mapping feature. So to convert this to what we want to use from the GoREST page, we get this. Besides this we also want to tell that the file is using pagination, so we will add the following We will also add a input field, that will contain the current page you are attempting to add get data from. We set up the URI with the updated page info, but this is something we do in the script get method area. Finally we set up the if statement and add the info to the output variable that we finally push to get the data back. Note that I also use the function Add() to add a number to the current page and get the next one. Finally we have the whole document done. You can see how it should look here. After doing the changes it is not necessary to deploy or synchronize anything, just executing the table/task is enough. If you want to see what pages it iterates through, add a log to your setup, like explained in the following guide.  Setting the verbosity to more than 3 will then add actual data from the source, so do only set it that high if you remember to truncate the log before trying something. This is the best way to see, what happens with calls and so when it doesn't work. Finally when executed it will contain this amount of data. enum Normally I would not use it for a single page get as this, but when you use a nested get calls. More of that in the next paragraph. input output requirement in. URI {page} 1 output PageCount The reason for this is to get the maximum number of pages from the metadata and then use it as the endpoint of the enum range. In the enum itself I first set the current step in the range _value and sets it to the Page. Then I use that to replace {page} with the current range number and in the call i push the output with the item=\"out\" command. PageCount  Page In the end the file will look like this. The usual issue for when you use this is the following. You have some users, which you can get, but you also want to get the posts of those users. So something like this. https://gorest.co.in/public-api/users/{userid}/posts That only gave the info from one customer, but you want to get all users and all their posts in one table. This is because there is no way to just get all posts with a relation to the user or similar. This can even be more extreme, where you also wants to get the comments on the posts as well. More on that later, but first the posts of the users. First of you will need to add the following command even if you are not doing pagination. I have this rest call I need to do to get a list of stops on a transport. There is no need for pagination it will give all of the stops in one call. The issue is that to get a stop I need to specify a file id. I have a rest call that can give me all these ids. So I just need to mix them in a nested call to make it iterate over each file id. First I need to define all the fields. XPath First part is this. URLBase URL  URITemplate  URI Then I set up the necessary parts for the call to get the list of file ids. JSON path ElementMap  filein getallstops URITemplate  {file_id} enablepaging  JSONPath  stopin Then I set up my first call. filenin  URITemplate  filein.URI  filein  fileout URI fileout  filein.file_id stopin URI  Replace() {file_id} Once this is done I run the second call inside the first one. stopin  stopout  stopout GetAllStops.RSD You can also use an parameter to make it work and it can be that you want the parameter to be something dynamic, or something you apply in TimeXtender instead of in the RSD file. fixer.io URI http://data.fixer.io/api/2020-03-15?access_key=522b683569a91b66be6be214027b47bf RSD  RSD <input> and <api:check> datein To use this file you will have to make a managed query table in your REST data source. You can use it in a query like so. If the rest provider only works if you provide a filter like from date and to date you can also add custom URL parameters and use them the same way. Such as this. And custom URL parameters can also be mixed with pagination as well. This is an method that works if it is only an single level you go down, but can't do more than one. Record Offset Page Number Below is how to set up the invoice id field as an input field. URI  {}  [_input.postid] other:filter=\"{input name}\" To see the other values than the default URI I added to the match method, you will have to add a managed query to add the rule to. invoiceId  IN You can see how this happens if you add a log to the setup. It will show the query in that. jsonproviderGet 'date' 'yesterday' dateadd  todate() So with this you can make it have a range from first of month, by changing day to month and you can do the same for to. If you want it to look way into the future change it yo year instead. RSD URI URI  {from} {to} To set this up in the call I do the following. -1 +1 This can then be used in conjunction with incremental load to decrease the number of rows the program is going through. The only necessity is that the API has the option to filter by date. Additionally, there is some more info about this in the link added to the first section. ",
    "Lists": [
        {
            "heading": "Push response header link method",
            "paragraphs": [
                "If your API has the following setup. The proposed standard RFC-8288 is to include information about the current page in the HTTP header.",
                "In more detail, the following information is included in the Header:"
            ],
            "list": [
                "Per-Page: the number of results shown per page",
                "Page: the currently displayed page",
                "Link: a set of RFC-8288 encoded links to the first, next, previous, and last pages (if applicable).",
                "Total: the total number of results"
            ]
        },
        {
            "heading": "Page",
            "paragraphs": [
                "The following method is for the PushResponseHeader Page method."
            ],
            "list": [
                "You push header names onto the end of the PushResponseHeader# input array, which will mark them to be saved.",
                "Set any other inputs and invoke jsonproviderGet / xmlproviderGet",
                "Read the result from the header: set of output attributes, which are named based on the inputs given to the push header array. For example, if you set the push headers so it contains the values [Per-Page, Page] then the header values will be set on the header:Per-Page and header:Page attributes of the output item."
            ]
        }
    ]
}